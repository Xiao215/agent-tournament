import json
import random
import re
import textwrap
from abc import ABC, abstractmethod
from dataclasses import asdict, dataclass
from enum import Enum
from typing import Any, Callable, Self, Sequence

from src.agents.agent_manager import Agent
from src.logger_manager import LOGGER
from src.utils.concurrency import run_tasks


class Action(Enum):
    """Base class for actions in the game"""

    def to_token(self) -> str:
        """Convert the action to a token (eg, A1) starting from A0 for LLM parsing."""
        idx = list(type(self)).index(self)
        return f"A{idx}"

    @classmethod
    def from_token(cls, token: str) -> Self:
        """Parse an action from a token like "A0" or "A1"."""
        try:
            idx = int(token.lstrip("A"))
            action = list(cls)[idx]
        except Exception as exp:
            raise ValueError(f"Unknown action token {token!r}") from exp
        return action

    @classmethod
    def from_index(cls, index: int) -> Self:
        """Get action from its index."""
        try:
            action = list(cls)[index]
        except Exception as exp:
            raise ValueError(f"Unknown action index {index!r}") from exp
        return action


@dataclass
class Move:
    """
    A record of one player's action in a single round.

    Attributes:
        name: The name of the player.
        action: The action taken by the player.
        points: The points scored by the player in this round.
        response: The full response generated by the player.
    """

    label: str
    name: str
    action: Action
    points: float
    response: str

    def to_dict(self) -> dict[str, Any]:
        d = asdict(self)
        d["action"] = self.action.value
        return d


class Game(ABC):
    """
    Base class for all games in the tournament.
    """

    def __init__(
        self,
        prompt: str,
        num_players: int,
        num_actions: int,
    ) -> None:
        self.prompt = prompt
        self.num_players = num_players
        self.num_actions = num_actions
        self.default_output_instruction = textwrap.dedent(
            """
        Instruction:
        - Choose a probability distribution over the provided actions each round.
        - Output must contain a valid JSON object at the end.
        - Keys must be the action names exactly as given.
        - Values must be integers between 0 and 100.
        - The two values must sum to exactly 100.

        Format requirement:
        Return exactly one JSON object, for example:
        {"A0": <INT>, "A1": <INT>, ...}
        """
        )

    @abstractmethod
    def play(
        self,
        additional_info: list[str] | str,
        players: Sequence[Agent],
        action_map: Callable = lambda x: x,
    ) -> list[Move]:
        """Play the game."""
        raise NotImplementedError

    def prompt_player_mix_probs(
        self,
        player: Agent,
        mechanism_info: str | None = None,
        output_instruction: str | None = None,
    ) -> tuple[str, dict[int, float]]:
        """
        Given the mechanism's additional info and the base game prompt,
        format the full prompt and query the player.

        Returns the player's raw response.
        """
        prompt = self.prompt.format(
            player_name=player.name,
        )

        if mechanism_info:
            prompt += mechanism_info

        if output_instruction is None:
            output_instruction = self.default_output_instruction
        prompt += "\n" + output_instruction

        LOGGER.write_to_txt(prompt, "game_prompt.txt")
        resp, mix_probs = player.chat_with_retries(prompt, self._parse_mixed_probs)
        return resp, mix_probs

    def _parse_mixed_probs(
        self,
        response: str,
    ) -> dict[int, float]:
        """
        Parse mixed strategy pairs like '<A0=60>|<A1=25>|<A2=15>'.
        Rules:
        - integers only
        - each in [0,100]
        - sum exactly 100
        """
        matches = re.findall(r"\{.*?\}", response, re.DOTALL)
        if not matches:
            raise ValueError(f"No JSON object found in the response {response!r}")
        json_str = matches[-1]

        try:
            json_obj = json.loads(json_str)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON: {e.msg}") from e

        result = {}
        total = 0
        for k, v in json_obj.items():
            if not isinstance(v, int):
                raise ValueError(f"Value for {k} must be an integer, got {v!r}")
            if not 0 <= v <= 100:
                raise ValueError(f"Value for {k} must be between 0 and 100, got {v}")
            idx = int(k[1:])  # strip the leading 'A'
            result[idx] = v
            total += v

        got_keys = set(result.keys())
        missing = set(range(self.num_actions)) - got_keys
        if missing:
            raise ValueError(f"Action key mismatch. Missing: {sorted(missing)}")

        if total != 100:
            raise ValueError(f"Probabilities must sum to 100 (got {total}).")

        return result

    def _build_retry_prompt(
        self,
        bad_response: str,
        error_reason: str,
    ) -> str:
        """Restate base prompt, show prior answer + reason, and add a single-line hint."""
        br = bad_response.replace("\n", " ")[:500]
        return (
            f"{self.default_output_instruction}\n"
            f"Your previous response was:\n{br}\n"
            f"That response is INVALID because: {error_reason}\n"
            f"Please reflect on the error and provide the mixed strategy again based on the previous response!"
        )

    @staticmethod
    def _choose_from_mix_strategy(probs: dict[int, float]) -> int:
        r = random.random() * sum(probs.values())
        acc = 0.0
        for k, w in probs.items():
            acc += w
            if r <= acc:
                return k
        # floating-point edge case fallback
        return next(reversed(probs))

    def _collect_actions(
        self,
        players: Sequence[Agent],
        info: Sequence[str],
        *,
        parallel: bool,
    ) -> list[tuple[str, int, str]]:
        """Prompt players (optionally in parallel) and sample actions."""

        if len(players) != len(info):
            raise ValueError(
                f"Player count ({len(players)}) does not match info entries ({len(info)})."
            )

        def query(player: Agent, extra_info: str) -> tuple[str, int, str]:
            resp, mix_probs = self.prompt_player_mix_probs(player, extra_info)
            action_idx = self._choose_from_mix_strategy(mix_probs)
            return player.label, action_idx, resp

        pairs = list(zip(players, info))
        if not parallel:
            return [query(player, extra) for player, extra in pairs]

        return run_tasks(pairs, lambda pair: query(*pair), max_workers=len(players))
