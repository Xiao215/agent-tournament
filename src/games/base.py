import random
import re
from abc import ABC, abstractmethod
from dataclasses import dataclass, asdict
from enum import Enum
from typing import Callable, Self, Sequence, Any
import json
from src.agents.agent_manager import Agent
from src.logger_manager import write_to_txt

import textwrap

random.seed(42)


class Action(Enum):
    """Base class for actions in the game"""

    def to_token(self) -> str:
        """Convert the action to a token (eg, A1) starting from A0 for LLM parsing."""
        idx = list(type(self)).index(self)
        return f"A{idx}"

    @classmethod
    def from_token(cls, token: str) -> Self:
        """Parse an action from a token like "A0" or "A1"."""
        try:
            idx = int(token.lstrip("A"))
            action = list(cls)[idx]
        except Exception as exp:
            raise ValueError(f"Unknown action token {token!r}") from exp
        return action

    @classmethod
    def from_index(cls, index: int) -> Self:
        """Get action from its index."""
        try:
            action = list(cls)[index]
        except Exception as exp:
            raise ValueError(f"Unknown action index {index!r}") from exp
        return action


class Game(ABC):
    """
    Base class for all games in the tournament.
    """

    @dataclass(frozen=True)
    class Move:
        """
        A record of one player's action in a single round.

        Attributes:
            name: The name of the player.
            action: The action taken by the player.
            points: The points scored by the player in this round.
            response: The full response generated by the player.
        """

        name: str
        action: Action
        points: float
        response: str

        def to_dict(self) -> dict[str, Any]:
            d = asdict(self)
            d["action"] = self.action.value
            return d

    def __init__(
        self,
        prompt: str,
        num_players: int,
        num_actions: int,
    ) -> None:
        self.prompt = prompt
        self.num_players = num_players
        self.num_actions = num_actions
        self.default_output_instruction = textwrap.dedent(
            """
        Instruction:
        - Choose a probability distribution over the provided actions each round.
        - Output must contain a valid JSON object at the end.
        - Keys must be the action names exactly as given.
        - Values must be integers between 0 and 100.
        - The two values must sum to exactly 100.

        Format requirement:
        Return exactly one JSON object, for example:
        {"A0": <INT>, "A1": <INT>, ...}
        """
        )

    @abstractmethod
    def play(
        self,
        additional_info: list[str] | str,
        players: Sequence[Agent],
        action_map: Callable = lambda x: x,
    ) -> list[Move]:
        """Play the game."""
        raise NotImplementedError

    def prompt_player(
        self,
        player: Agent,
        additional_info: str | None = None,
        output_instruction: str | None = None,
    ) -> str:
        """
        Given the mechanism's additional info and the base game prompt,
        format the full prompt and query the player.

        Returns the player's raw response.
        """
        prompt = self.prompt.format(
            player_name=player.name,
            instruction=output_instruction or self.default_output_instruction,
        )
        if additional_info:
            prompt += additional_info

        write_to_txt(prompt, "game_prompt.txt")
        print(prompt)
        resp = player.chat(prompt)
        return resp

    def _parse_mixed_probs(
        self,
        response: str,
    ) -> dict[int, float]:
        """
        Parse mixed strategy pairs like '<A0=60>|<A1=25>|<A2=15>'.
        Rules:
        - integers only
        - each in [0,100]
        - sum exactly 100
        """
        matches = re.findall(r"\{.*?\}", response, re.DOTALL)
        if not matches:
            raise ValueError(f"No JSON object found in the response {response!r}")
        json_str = matches[-1]

        try:
            json_obj = json.loads(json_str)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON: {e.msg}") from e

        result = {}
        total = 0
        for k, v in json_obj.items():
            if not isinstance(v, int):
                raise ValueError(f"Value for {k} must be an integer, got {v!r}")
            if not (0 <= v <= 100):
                raise ValueError(f"Value for {k} must be between 0 and 100, got {v}")
            idx = int(k[1:])  # strip the leading 'A'
            result[idx] = v
            total += v

        got_keys = set(result.keys())
        missing = set(range(self.num_actions)) - got_keys
        if missing:
            raise ValueError(f"Action key mismatch. Missing: {sorted(missing)}")

        if total != 100:
            raise ValueError(f"Probabilities must sum to 100 (got {total}).")

        return result

    def _build_retry_prompt(
        self,
        bad_response: str,
        error_reason: str,
    ) -> str:
        """Restate base prompt, show prior answer + reason, and add a single-line hint."""
        br = bad_response.replace("\n", " ")[:500]
        return (
            f"{self.default_output_instruction}\n"
            f"Your previous response was:\n{br}\n"
            f"That response is INVALID because: {error_reason}\n"
            f"Please reflect on the error and provide the mixed strategy again based on the previous response!"
        )

    def _extract_mixed_strategy(
        self,
        player: Agent,
        response: str,
        additional_info: str,
        max_retries: int = 5,
    ) -> dict[int, float]:
        """
        Ask for a mixed strategy and parse with targeted retries.
        Mirrors your disarm-caps control flow:
        base_prompt -> parse -> on error: _build_retry_prompt(..., error_reason) -> retry
        """
        error_reason = ""

        # initial + retries
        for attempt in range(max_retries + 1):
            if attempt != 0:
                response = self.prompt_player(
                    player,
                    output_instruction=self._build_retry_prompt(response, error_reason),
                    additional_info=additional_info,
                )

            try:
                return self._parse_mixed_probs(response)
            except ValueError as e:
                error_reason = str(e)
                print(
                    f"Attempt {attempt + 1} of {player.name} to parse mixed strategy failed: "
                    f"{error_reason} from response {response!r}"
                )

        raise ValueError(
            f"Failed to parse mixed strategy after {1 + max_retries} attempts. "
            f"Last error: {error_reason}. Last response: {response!r}"
        )

    @staticmethod
    def _choose_from_mix_strategy(probs: dict[int, float]) -> int:
        r = random.random() * sum(probs.values())
        acc = 0.0
        for k, w in probs.items():
            acc += w
            if r <= acc:
                return k
        # floating-point edge case fallback
        return next(reversed(probs))
