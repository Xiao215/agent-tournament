diff --git a/interactive.sh b/interactive.sh
index 122b549..159285a 100644
--- a/interactive.sh
+++ b/interactive.sh
@@ -1,5 +1,5 @@
 srun --account=aip-rgrosse --time=1:00:00 --gres=gpu:l40s:2 --mem=48G -c 32 --chdir=/project/aip-rgrosse/xiao215/agent-tournament --pty bash
-srun --account=aip-rgrosse --time=1:00:00 --gres=gpu:h100:2 --mem=80G -c 24 --chdir=/project/aip-rgrosse/xiao215/agent-tournament --pty bash
+srun --account=aip-rgrosse --time=1:00:00 --gres=gpu:h100:2 --mem=48G -c 32 --chdir=/project/aip-rgrosse/xiao215/agent-tournament --pty bash
 sinfo -N --Format=NodeHost,Partition,GresUsed,Gres,CPUsState
 squeue -u $USER
 srun --account=aip-rgrosse --time=1:00:00 --gres=gpu:l40s:2 --mem=80G -c 24 --chdir=/project/aip-rgrosse/xiao215/agent-tournament --pty bash
diff --git a/results/jsonl_to_json.py b/results/jsonl_to_json.py
index 4a78f5c..4faf44a 100644
--- a/results/jsonl_to_json.py
+++ b/results/jsonl_to_json.py
@@ -1,6 +1,6 @@
-import sys
 import json
 import os
+import sys
 
 
 def convert_jsonl_to_json(input_path: str):
diff --git a/script/run_evolution.py b/script/run_evolution.py
index 0af7977..ae84132 100644
--- a/script/run_evolution.py
+++ b/script/run_evolution.py
@@ -10,6 +10,7 @@ from config import CONFIG_DIR, OUTPUTS_DIR
 from src.evolution.replicator_dynamics import DiscreteReplicatorDynamics
 from src.plot import plot_probability_evolution
 from src.registry import GAME_REGISTRY, MECHANISM_REGISTRY, create_agent
+from src.wandb_logger import WandBLogger
 
 now = datetime.now()
 log_dir = OUTPUTS_DIR / f"{now.year}" / f"{now.month:02}" / f"{now.day:02}"
@@ -40,6 +41,9 @@ def main():
     parser = argparse.ArgumentParser()
     parser.add_argument('--config', type=str)
     # parser.add_argument('--log', action='store_true', help='Enable logging')
+    parser.add_argument(
+        "--wandb", action="store_true", help="Enable Weights & Biases figure saving"
+    )
 
     args = parser.parse_args()
 
@@ -72,9 +76,15 @@ def main():
         steps=config["evolution"]["steps"],
     )
 
+    wb = None
+    if args.wandb:
+        wb = WandBLogger(project="llm-evolution", config=config)
+
     plot_probability_evolution(
         trajectory=population_history,
         labels=[agent.name for agent in agents],
+        wb=wb,
+        save_local=True,
     )
 
 if __name__ == "__main__":
diff --git a/src/agent.py b/src/agent.py
index 54b8427..932df57 100644
--- a/src/agent.py
+++ b/src/agent.py
@@ -12,9 +12,9 @@ hf_logging.set_verbosity_error()
 torch.set_float32_matmul_precision("high")
 
 torch.manual_seed(42)
-torch.cuda.manual_seed_all(42)
-torch.backends.cudnn.deterministic = True
-torch.backends.cudnn.benchmark = False
+# torch.cuda.manual_seed_all(42)
+# torch.backends.cudnn.deterministic = True
+# torch.backends.cudnn.benchmark = False
 
 class LLMInstance():
     """A class to manage a Hugging Face LLM pipeline that can be moved between CPU and GPU."""
diff --git a/src/analysis/wandb_logger.py b/src/analysis/wandb_logger.py
deleted file mode 100644
index afd37ec..0000000
--- a/src/analysis/wandb_logger.py
+++ /dev/null
@@ -1,15 +0,0 @@
-import wandb
-from typing import Any
-
-
-class WandBLogger:
-    """Minimal wrapper so your plotting code never touches wandb directly."""
-
-    def __init__(self, project: str, config: dict[str, Any] | None = None):
-        self.run = wandb.init(
-            project=project, config=config or {}, save_code=True, reinit=True
-        )
-
-    def log_figure(self, fig, name: str, step: int | None = None):
-        """Log a Matplotlib figure as an image artefact."""
-        self.run.log({name: wandb.Image(fig)}, step=step)
diff --git a/src/plot.py b/src/plot.py
index e07bd88..5e5599e 100644
--- a/src/plot.py
+++ b/src/plot.py
@@ -1,250 +1,172 @@
 from datetime import datetime
 from pathlib import Path
+from typing import Any, Sequence
 
 import matplotlib.pyplot as plt
 import numpy as np
-from matplotlib.patches import Polygon
+from matplotlib.figure import Figure
+from matplotlib.typing import ColorType
 
 from config import FIGURE_DIR
+from src.wandb_logger import WandBLogger
 
 
-def save_figure(fig, filename: str) -> Path:
+def _ensure_date_dir() -> Path:
     """
-    Save a Matplotlib figure under FIGURE_DIR/yyyy/mm/dd/<hh_mm_filename>.
+    Create date-based directory under FIGURE_DIR/YYYY/MM/DD and return it.
     """
-    # Build date‐based subfolder
     now = datetime.now()
     date_path = (
         Path(FIGURE_DIR) / now.strftime("%Y") / now.strftime("%m") / now.strftime("%d")
     )
     date_path.mkdir(parents=True, exist_ok=True)
+    return date_path
 
-    # Prepend hour and minute to filename
-    time_prefix = now.strftime("%H_%M")
-    new_filename = f"{time_prefix}_{filename}"
 
-    # Full filepath
-    filepath = date_path / new_filename
-
-    # Save with tight layout
-    fig.savefig(filepath, bbox_inches="tight")
-    return filepath
-
-def plot_probability_evolution(
-        trajectory: list[np.ndarray],
-        colors: list[str] | None = None,
-        labels: list[str] | None = None,
-        figsize: tuple[int, int] = (10, 6)
-    ) -> None:
+def _save_local(fig: Figure, filename: str) -> Path:
     """
-    Plot the evolution of a probability distribution over time as a stacked area chart.
-
-    Parameters:
-    -----------
-    trajectory : list of numpy arrays
-        Each array is a probability distribution at a given time step.
-        Each array should be shape (n,) and sum to 1.
-    colors : list, optional
-        Colors for each item. If None, uses default matplotlib colormap
-    labels : list, optional
-        Labels for each item. If None, uses "Item 0", "Item 1", etc.
-    figsize : tuple
-        Figure size (width, height)
-
-    Returns:
-    --------
-    fig, ax : matplotlib figure and axes objects
+    Save figure locally under FIGURE_DIR with timestamp prefix.
+    Returns the full filepath.
     """
-
-    # Convert trajectory to 2D array: (time_steps, n_items)
-    prob_matrix = np.array(trajectory)
-    n_time_steps, n_items = prob_matrix.shape
-
-    # Validate that probabilities sum to 1 (approximately)
-    sums = np.sum(prob_matrix, axis=1)
-    if not np.allclose(sums, 1.0, rtol=1e-3):
-        print(
-            (
-                "Warning: Some probability distributions don't sum to 1. "
-                f"Sums range from {sums.min():.4f} to {sums.max():.4f}"
-            )
+    date_path = _ensure_date_dir()
+    timestamp = datetime.now().strftime("%H_%M_%S")
+    out_path = date_path / f"{timestamp}_{filename}"
+    fig.savefig(out_path, bbox_inches="tight")
+    return out_path
+
+
+def _log_or_save(
+    fig: Figure,
+    filename: str,
+    wb: WandBLogger | None,
+    save_local: bool,
+) -> Path | None:
+    """
+    Either log to WandB, save locally, or both.
+    """
+    local_path = None
+    if wb:
+        wb.log_figure(
+            fig,
+            filename,
         )
+    if save_local:
+        local_path = _save_local(fig, filename)
+    plt.close(fig)
+    return local_path
 
-    # Compute cumulative sums for each time step
-    cumsum_matrix = np.cumsum(prob_matrix, axis=1)
 
-    # Add a column of zeros at the beginning for the base
-    cumsum_with_base = np.column_stack([np.zeros(n_time_steps), cumsum_matrix])
-
-    # Create time axis
-    time_axis = np.arange(n_time_steps)
+def plot_probability_evolution(
+    trajectory: Sequence[np.ndarray],
+    wb: WandBLogger | None,
+    save_local: bool,
+    colors: Sequence[ColorType] | None = None,
+    labels: Sequence[str] | None = None,
+    figsize: tuple[int, int] = (10, 6),
+) -> Path | None:
+    """
+    Stacked area chart of probability evolution.
 
-    # Set up colors
+    Returns local path if saved, otherwise None.
+    """
+    mat = np.array(trajectory)
+    steps, items = mat.shape
+    sums = mat.sum(axis=1)
+    if not np.allclose(sums, 1, rtol=1e-3):
+        print(f"Warning: distributions sum to [{sums.min():.4f}, {sums.max():.4f}]")
+    cumsum = np.cumsum(mat, axis=1)
+    base = np.hstack([np.zeros((steps, 1)), cumsum])
+    x = np.arange(steps)
     if colors is None:
-        cmap = plt.get_cmap('Set3')
-        colors = cmap(np.linspace(0, 1, n_items))
-
-    # Set up labels
+        cmap = plt.get_cmap("Set3")
+        colors = list(cmap(np.linspace(0, 1, items)))
     if labels is None:
-        labels = [f'Item {i}' for i in range(n_items)]
-
-    # Create the plot
+        labels = [f"Item {i}" for i in range(items)]
     fig, ax = plt.subplots(figsize=figsize)
-
-    # Plot stacked areas using fill_between
-    for i in range(n_items):
-        ax.fill_between(time_axis,
-                       cumsum_with_base[:, i],
-                       cumsum_with_base[:, i+1],
-                       color=colors[i],
-                       label=labels[i],
-                       alpha=0.8,
-                       edgecolor='white',
-                       linewidth=0.5)
-
-    ax.set_xlabel('Time Step')
-    ax.set_ylabel('Cumulative Probability')
-    ax.set_title('Evolution of Probability Distribution Over Time')
-    ax.set_ylim(0, 1)
-    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
-    ax.grid(True, alpha=0.3)
-
-    saved_path = save_figure(fig, "population_evolution.png")
-    print(f"Population evolution plot saved to {saved_path}")
-
-
-def plot_share_progression(pop_payoff, dynamics_results):
-    """
-    Plot the evolution of a population distribution over time as a stacked area chart
-    with overlaid payoff trajectory.
-
-    Parameters:
-    -----------
-    pop_payoff : an instance of Population_Payoffs
-    dynamics_results: contains the following:
-        trajectory : list of numpy arrays
-            Each array is a population distribution at a given time step.
-        pay_traj : list of float
-            Payoff values at each time step.
-        status : status of the dynamics
-
-    Returns:
-    --------
-    fig, (ax1, ax2) : matplotlib figure and axes objects
-        ax1: primary axis for population shares
-        ax2: secondary axis for payoff trajectory
-    """
-    pop_traj, pay_traj, status = dynamics_results
-
-
-
-    # Convert trajectory to 2D array and transpose for stackplot
-    prob_matrix = np.array(pop_traj).T  # Shape: (n_types, n_time_steps)
-
-    # Get indices that would sort the final population in descending order
-    sorted_indices = np.argsort( -prob_matrix[:, -1] )  # Negative to sort in descending order
-
-    # Reorder prob_matrix rows based on final population values
-    prob_matrix = prob_matrix[sorted_indices]
-
-    # Also reorder the labels accordingly
-    labels = [pop_payoff.agent_types[i] for i in sorted_indices]
-
-    n_types, n_time_steps = prob_matrix.shape
-
-    # Create time axis
-    time_axis = np.arange(n_time_steps)
-
-    # Set up colors
-    cmap = plt.get_cmap('Set3')
-    colors = cmap(np.linspace(0, 1, n_types))
-
-    # Create the plot
+    for i in range(items):
+        ax.fill_between(
+            x,
+            base[:, i],
+            base[:, i + 1],
+            color=colors[i],
+            label=labels[i],
+            alpha=0.8,
+            edgecolor="white",
+            linewidth=0.5,
+        )
+    ax.set(
+        xlabel="Time Step",
+        ylabel="Cumulative Prob",
+        title="Prob Evolution",
+        ylim=(0, 1),
+    )
+    ax.legend(loc="upper left", bbox_to_anchor=(1.05, 1))
+    ax.grid(alpha=0.3)
+    return _log_or_save(fig, "prob_evolution.png", wb, save_local)
+
+
+def plot_share_progression(
+    pop_payoff: Any,
+    dynamics: Any,
+    wb: WandBLogger | None = None,
+    save_local: bool = False,
+) -> Path | None:
+    pop_traj, pay_traj, status = dynamics
+    mat = np.array(pop_traj).T
+    order = np.argsort(-mat[:, -1])
+    mat = mat[order]
+    labels = [pop_payoff.agent_types[i] for i in order]
+    x = np.arange(mat.shape[1])
+    cmap = plt.get_cmap("Set3")
+    colors = cmap(np.linspace(0, 1, mat.shape[0]))
     fig, ax1 = plt.subplots(figsize=(12, 6))
-
-    # Plot stacked areas for population shares
-    ax1.stackplot(time_axis, *prob_matrix, colors=colors, labels=labels, alpha=0.7)
-    ax1.set_xlabel('Time Step')
-    ax1.set_ylabel('Share of Population', color='black')
-    ax1.set_ylim(0, 1)
-    ax1.set_xlim(0, n_time_steps - 1)
-
-    # Add a thick horizontal line at y=1
-    ax1.axhline(y=1, color='black', linestyle='--', linewidth=1)
-    ax1.grid(True, alpha=0.3)
-
-    # Create secondary y-axis for payoff trajectory
+    ax1.stackplot(x, *mat, colors=colors, labels=labels, alpha=0.7)
+    ax1.set(xlabel="Time Step", ylabel="Share", ylim=(0, 1), xlim=(0, x[-1]))
+    ax1.axhline(1, linestyle="--", linewidth=1)
+    ax1.grid(alpha=0.3)
     ax2 = ax1.twinx()
-    payoff_line = ax2.plot(time_axis, pay_traj, color='red', linewidth=3,
-                          label='Average Payoff', alpha=0.9)
-    ax2.set_ylabel('Average Population Payoff', color='red')
-    ax2.tick_params(axis='y', labelcolor='red')
-    # Set y-axis limits for the payoff plot based on min/max values in the payoff tensor
-    ax2.set_ylim(pop_payoff.payoff_tensor.min(), pop_payoff.payoff_tensor.max())
-    # Set title
-    ax1.set_title('Evolution of Population Shares and Average Population Payoff Over Time')
-
-    # Add invisible line with status as label (using circle marker)
-    status_line = ax1.plot([], [], 'o', markersize=5, markerfacecolor='white',
-                          markeredgecolor='black', label=f'Status: {status}')
-
-    # Combine legends from both axes
-    lines1, labels1 = ax1.get_legend_handles_labels()
-    lines2, labels2 = ax2.get_legend_handles_labels()
-    ax1.legend(lines1 + lines2, labels1 + labels2,
-              bbox_to_anchor=(1.15, 1), loc='upper left')
-
-    plt.tight_layout()
-    return fig, (ax1, ax2)
-
-
-def plot_3simplex_trajectories(trajectories):
-    """Plot trajectories on the 3-strategy simplex"""
+    ax2.plot(x, pay_traj, color="red", linewidth=3, label="Payoff")
+    ax2.set_ylabel("Payoff", color="red")
+    ax2.tick_params(labelcolor="red")
+    ax1.set_title(f"Share & Payoff (status={status})")
+    lines, labs = ax1.get_legend_handles_labels()
+    l2, l2_labels = ax2.get_legend_handles_labels()
+    ax1.legend(lines + l2, labs + l2_labels, bbox_to_anchor=(1.15, 1))
+    fig.tight_layout()
+    return _log_or_save(fig, "share_progress.png", wb, save_local)
+
+
+def plot_3simplex_trajectories(
+    trajectories: Sequence[Sequence[np.ndarray]],
+    wb: WandBLogger | None = None,
+    save_local: bool = False,
+) -> Path | None:
     fig, ax = plt.subplots(figsize=(10, 8))
+    from matplotlib.patches import Polygon
 
-    # Draw simplex triangle
-    triangle = Polygon([(0, 0), (1, 0), (0.5, np.sqrt(3)/2)],
-                        fill=False, edgecolor='black', linewidth=2)
+    triangle = Polygon(
+        [(0, 0), (1, 0), (0.5, np.sqrt(3) / 2)],
+        fill=False,
+        edgecolor="black",
+        linewidth=2,
+    )
     ax.add_patch(triangle)
 
-    # Convert simplex coordinates to triangle coordinates
-    def simplex_to_triangle(p0, p1, p2):
-        x = p1 + p2/2
-        y = p2 * np.sqrt(3)/2
-        return x, y
-
-    # Plot trajectories
-    colors = ['red', 'blue', 'green', 'purple', 'orange']
-    for i, trajectory in enumerate(trajectories):
-        x_coords, y_coords = [], []
-        for state in trajectory:
-            x, y = simplex_to_triangle(state[0], state[1], state[2])
-            x_coords.append(x)
-            y_coords.append(y)
-
-        ax.plot(x_coords, y_coords, color=colors[i % len(colors)],
-                alpha=0.7, linewidth=2, label=f'Trajectory {i+1}')
-        ax.plot(x_coords[0], y_coords[0], 'o', color=colors[i % len(colors)],
-            markersize=8)
-        ax.plot(x_coords[-1], y_coords[-1], 's', color=colors[i % len(colors)],
-            markersize=8)
-
-    ax.plot([], [], 'o', color='black', markersize=8, label='Start')
-    ax.plot([], [], 's', color='black', markersize=8, label='End')
-
-    # Labels for corners
-    ax.text(-0.05, -0.05, 'Type 0', fontsize=12, ha='center')
-    ax.text(1.05, -0.05, 'Type 1', fontsize=12, ha='center')
-    ax.text(0.5, np.sqrt(3)/2 + 0.05, 'Type 2', fontsize=12, ha='center')
-
-    ax.set_xlim(-0.1, 1.1)
-    ax.set_ylim(-0.1, np.sqrt(3)/2 + 0.1)
-    ax.set_aspect('equal')
-    ax.axis('off')
-    ax.set_title('Evolutionary Game Dynamics',
-                fontsize=14, fontweight='bold')
-
-
-    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
-    plt.tight_layout()
-    return fig, ax
+    def to_xy(p):
+        return (p[1] + p[2] / 2, p[2] * np.sqrt(3) / 2)
+
+    colors = plt.get_cmap("Set3")(np.linspace(0, 1, len(trajectories)))
+    for i, traj in enumerate(trajectories):
+        xs, ys = zip(*[to_xy(*state) for state in traj])
+        ax.plot(xs, ys, color=colors[i], alpha=0.7, label=f"Traj {i+1}")
+        ax.scatter(
+            [xs[0], xs[-1]],
+            [ys[0], ys[-1]],
+            s=50,
+            marker="o" if i == 0 else "s",
+            color=colors[i],
+        )
+    ax.axis("off")
+    ax.legend(loc="upper left", bbox_to_anchor=(1.05, 1))
+    ax.set_title("3-Simplex Dynamics")
+    return _log_or_save(fig, "simplex.png", wb, save_local)
